localScan = function(libPath) //metaxploit scan a local lib
    locals.original_outers = {}
    locals.original_globals = {}
    for o in outer
        if o["key"] == "remove" then //if "remove" is injected in outer, we try to crash the script
            @you_cant_name_a_variable_remove_or_else_api_wont_work //if this name is not injected the script crashes here with prompt for the user
            0 = 0 //if the prompt is injected, here is still an elegent way to crash the script
            return null //this is another way if 0 = 0 no longer is error in future update
        end if
        locals.original_outers[o["key"]] = o["value"] //store those variable in a local map
    end for
    for g in globals
        if g["key"] == "remove" then //same as outer
            @you_cant_name_a_variable_remove_or_else_api_wont_work
            0 = 0
            return null
        end if
        locals.original_globals[g["key"]] = g["value"] 
    end for
    for o in locals.original_outers
        remove(outer, o["key"]) //remove all key-value pair in outer to prevent injection
    end for
    for g in locals.original_globals
        remove(globals, g["key"])
    end for
    if not outer == {} then 0 = 0 //double check if the outer map is empty, if not we try to crash the script
    if not globals == {} then 0 = 0

    if @libPath isa funcRef then exit("Function reference passed as argument.")
    remoteShell = get_shell.connect_service("xxx.xxx.xxx.xxx", 22, "root", "password")
    if not typeof(remoteShell) == "shell" then print("Database server down. Please report to owner. This does not affect exploit scan.")
    metaxploit = include_lib(current_path + "/metaxploit.so")
    if not typeof(metaxploit) == "MetaxploitLib" then metaxploit = include_lib("/lib/metaxploit.so")
    if not typeof(metaxploit) == "MetaxploitLib" then
        print("metaxploit.so not found in current path or /lib")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    metaLib = metaxploit.load(libPath)
    if not typeof(metaLib) == "MetaLib" then
        print("lib not found.")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    ret = {}
    ret.lib_name = metaLib.lib_name
    ret.version = metaLib.version
    ret.memorys = {}
    memorys = metaxploit.scan(metaLib)
    for memory in memorys
        addresses = split(metaxploit.scan_address(metaLib, memory), "Unsafe check:")
        ret.memorys[memory] = []
        for address in addresses
            if address == addresses[0] then continue
            value = address[indexOf(address, "<b>") + 3:indexOf(address, "</b>")]
            value = replace(value, "\n", "")
            ret.memorys[memory] = ret.memorys[memory] + [value]
        end for
    end for
    if typeof(remoteShell) == "shell" then
        remoteComputer = remoteShell.host_computer
        remoteFile = remoteComputer.File("/")
        remoteFile.chmod("u-rwx", true)
        remoteFile.chmod("g-rwx", true)
        remoteFile.chmod("o-rwx", true) //secure the server
        remoteDatabase = remoteComputer.File("/root/exploitDB")
        libFolderName = replace(ret.lib_name, "_", "0")
        libFolder = remoteComputer.File("/root/exploitDB/" + libFolderName)
        if not typeof(libFolder) == "file" then
            remoteComputer.create_folder("/root/exploitDB", libFolderName)
            libFolder = remoteComputer.File("/root/exploitDB/" + libFolderName)
        end if
        versionFolder = remoteComputer.File(libFolder.path + "/" + ret.version)
        if not typeof(versionFolder) == "file" then
            remoteComputer.create_folder(libFolder.path, ret.version)
            versionFolder = remoteComputer.File(libFolder.path + "/" + ret.version)
        end if
        for memory in ret.memorys
            memoryFileName = memory["key"]
            memoryFilePath = versionFolder.path + "/" + memoryFileName
            memoryFile = remoteComputer.File(memoryFilePath)
            if not typeof(memoryFile) == "file" then
                remoteComputer.touch(versionFolder.path, memoryFileName)
                memoryFile = remoteComputer.File(memoryFilePath)
            end if
            valueString = memoryFile.get_content
            while (len(valueString) > 0) and (valueString[0] == char(10)) //remove front and end empty line
                valueString = valueString[1:]
            end while
            while (len(valueString) > 0) and (valueString[-1] == char(10))
                valueString = valueString[:-1]
            end while
            valueList = split(valueString, char(10))
            for value in memory["value"]
                if not indexOf(valueList, value) == null then continue
                valueList = valueList + [value]
            end for
            valueString = join(valueList, char(10))
            memoryFile.set_content(valueString)
        end for
        remoteFile.chmod("u-rwx", true)
        remoteFile.chmod("g-rwx", true)
        remoteFile.chmod("o-rwx", true) //again
    end if
    for o in locals.original_outers
        outer[o["key"]] = o["value"]
    end for
    for g in locals.original_globals
        globals[g["key"]] = g["value"]
    end for
    return ret
end function
remoteScan = function(ip, port) //metaxploit scan a remote machine with ip and port
    locals.original_outers = {}
    locals.original_globals = {}
    for o in outer
        if o["key"] == "remove" then //if "remove" is injected in outer, we try to crash the script
            @you_cant_name_a_variable_remove_or_else_api_wont_work //if this name is not injected the script crashes here with prompt for the user
            0 = 0 //if the prompt is injected, here is still an elegent way to crash the script
            return null //this is another way if 0 = 0 no longer is error in future update
        end if
        locals.original_outers[o["key"]] = o["value"] //store those variable in a local map
    end for
    for g in globals
        if g["key"] == "remove" then //same as outer
            @you_cant_name_a_variable_remove_or_else_api_wont_work
            0 = 0
            return null
        end if
        locals.original_globals[g["key"]] = g["value"] 
    end for
    for o in locals.original_outers
        remove(outer, o["key"]) //remove all key-value pair in outer to prevent injection
    end for
    for g in locals.original_globals
        remove(globals, g["key"])
    end for
    if not outer == {} then 0 = 0 //double check if the outer map is empty, if not we try to crash the script
    if not globals == {} then 0 = 0

    if @ip isa funcRef then exit("Function reference passed as argument.")
    if @port isa funcRef then exit("Function reference passed as argument.")
    remoteShell = get_shell.connect_service("xxx.xxx.xxx.xxx", 22, "root", "password")
    if not typeof(remoteShell) == "shell" then print("Database server down. Please report to owner. This does not affect exploit scan.")
    metaxploit = include_lib(current_path + "/metaxploit.so")
    if not typeof(metaxploit) == "MetaxploitLib" then metaxploit = include_lib("/lib/metaxploit.so")
    if not typeof(metaxploit) == "MetaxploitLib" then
        print("metaxploit.so not found in current path or /lib")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    if not port isa number then
        print("invalid port")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    netSession = metaxploit.net_use(ip, port)
    netSession = metaxploit.net_use(ip, port)
    if not typeof(netSession) == "NetSession" then
        print("unable to create net_session")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    metaLib = netSession.dump_lib
    if not typeof(metaLib) == "MetaLib" then
        print("unable to dump lib")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    ret = {}
    ret.lib_name = metaLib.lib_name
    ret.version = metaLib.version
    ret.memorys = {}
    memorys = metaxploit.scan(metaLib)
    for memory in memorys
        addresses = split(metaxploit.scan_address(metaLib, memory), "Unsafe check:")
        ret.memorys[memory] = []
        for address in addresses
            if address == addresses[0] then continue
            value = address[indexOf(address, "<b>") + 3:indexOf(address, "</b>")]
            value = replace(value, "\n", "")
            ret.memorys[memory] = ret.memorys[memory] + [value]
        end for
    end for
    if typeof(remoteShell) == "shell" then
        remoteComputer = remoteShell.host_computer
        remoteFile = remoteComputer.File("/")
        remoteFile.chmod("u-rwx", true)
        remoteFile.chmod("g-rwx", true)
        remoteFile.chmod("o-rwx", true) //secure the server
        remoteDatabase = remoteComputer.File("/root/exploitDB")
        libFolderName = replace(ret.lib_name, "_", "0")
        libFolder = remoteComputer.File("/root/exploitDB/" + libFolderName)
        if not typeof(libFolder) == "file" then
            remoteComputer.create_folder("/root/exploitDB", libFolderName)
            libFolder = remoteComputer.File("/root/exploitDB/" + libFolderName)
        end if
        versionFolder = remoteComputer.File(libFolder.path + "/" + ret.version)
        if not typeof(versionFolder) == "file" then
            remoteComputer.create_folder(libFolder.path, ret.version)
            versionFolder = remoteComputer.File(libFolder.path + "/" + ret.version)
        end if
        for memory in ret.memorys
            memoryFileName = memory["key"]
            memoryFilePath = versionFolder.path + "/" + memoryFileName
            memoryFile = remoteComputer.File(memoryFilePath)
            if not typeof(memoryFile) == "file" then
                remoteComputer.touch(versionFolder.path, memoryFileName)
                memoryFile = remoteComputer.File(memoryFilePath)
            end if
            valueString = memoryFile.get_content
            while (len(valueString) > 0) and (valueString[0] == char(10)) //remove front and end empty line
                valueString = valueString[1:]
            end while
            while (len(valueString) > 0) and (valueString[-1] == char(10))
                valueString = valueString[:-1]
            end while
            valueList = split(valueString, char(10))
            for value in memory["value"]
                if not indexOf(valueList, value) == null then continue
                valueList = valueList + [value]
            end for
            valueString = join(valueList, char(10))
            memoryFile.set_content(valueString)
        end for
        remoteFile.chmod("u-rwx", true)
        remoteFile.chmod("g-rwx", true)
        remoteFile.chmod("o-rwx", true) //again
    end if
    for o in locals.original_outers
        outer[o["key"]] = o["value"]
    end for
    for g in locals.original_globals
        globals[g["key"]] = g["value"]
    end for
    return ret
end function
queryExploit = function(libName, libVersion)
    locals.original_outers = {}
    locals.original_globals = {}
    for o in outer
        if o["key"] == "remove" then //if "remove" is injected in outer, we try to crash the script
            @you_cant_name_a_variable_remove_or_else_api_wont_work //if this name is not injected the script crashes here with prompt for the user
            0 = 0 //if the prompt is injected, here is still an elegent way to crash the script
            return null //this is another way if 0 = 0 no longer is error in future update
        end if
        locals.original_outers[o["key"]] = o["value"] //store those variable in a local map
    end for
    for g in globals
        if g["key"] == "remove" then //same as outer
            @you_cant_name_a_variable_remove_or_else_api_wont_work
            0 = 0
            return null
        end if
        locals.original_globals[g["key"]] = g["value"] 
    end for
    for o in locals.original_outers
        remove(outer, o["key"]) //remove all key-value pair in outer to prevent injection
    end for
    for g in locals.original_globals
        remove(globals, g["key"])
    end for
    if not outer == {} then 0 = 0 //double check if the map is empty, if not we try to crash the script
    if not globals == {} then 0 = 0

    if @libName isa funcRef then exit("Function reference passed as argument.")
    if @libVersion isa funcRef then exit("Function reference passed as argument.")
    libName = replace(libName, "_", "0")
    remoteShell = get_shell.connect_service("xxx.xxx.xxx.xxx", 22, "root", "password")
    if not typeof(remoteShell) == "shell" then
        print("Unable to reach database server. Please report to owner.")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    remoteComputer = remoteShell.host_computer
    remoteFile = remoteComputer.File("/")
    remoteFile.chmod("u-rwx", true)
    remoteFile.chmod("g-rwx", true)
    remoteFile.chmod("o-rwx", true) //secure the server
    libFolder = remoteComputer.File("/root/exploitDB/" + libName + "/" + libVersion)
    if not typeof(libFolder) == "file" then
        print("Unable to find exploit for this lib.")
        for o in locals.original_outers
            outer[o["key"]] = o["value"]
        end for
        for g in locals.original_globals
            globals[g["key"]] = g["value"]
        end for
        return null
    end if
    ret = {}
    ret.lib_name = replace(libName, "0", "_")
    ret.version = libVersion
    ret.memorys = {}
    for file in libFolder.get_files
        ret.memorys[file.name] = []
        valueString = file.get_content
        while (len(valueString) > 0) and (valueString[0] == char(10)) //remove front and end empty line
            valueString = valueString[1:]
        end while
        while (len(valueString) > 0) and (valueString[-1] == char(10))
            valueString = valueString[:-1]
        end while
        valueList = split(valueString, char(10))
        ret.memorys[file.name] = valueList
    end for
    remoteFile.chmod("u-rwx", true)
    remoteFile.chmod("g-rwx", true)
    remoteFile.chmod("o-rwx", true) //again
    for o in locals.original_outers
        outer[o["key"]] = o["value"]
    end for
    for g in locals.original_globals
        globals[g["key"]] = g["value"]
    end for
    return ret
end function
